class WaterDropSystem{constructor(t={}){this.config={dropInterval:200,minDropSize:3,breakpoint:"sm",backgroundColor:"transparent",defaultDropColor:{main:"rgba(135, 206, 235, ",shadow:"rgba(135, 206, 235, 0.5)",highlight:"rgba(255, 255, 255, 0.6)"},clickDropColor:{main:"rgba(30, 60, 120, ",shadow:"rgba(30, 60, 120, 0.5)",highlight:"rgba(100, 150, 255, 0.6)"},enabled:!0,...t},this.breakpoints={xs:0,sm:576,md:768,lg:992,xl:1200,xxl:1400},this.canvas=document.getElementById("canvas"),this.canvas?(this.ctx=this.canvas.getContext("2d"),this.drops=[],this.obstacles=[],this.resizeTimer=null,this.animationPaused=!1,this.lastTime=0,this.lastDropTime=0,this.animationEnabled=this.config.enabled,this.init()):console.error('Canvas element with id "canvas" not found')}init(){this.resizeCanvas(),this.updateObstacles(),this.bindEvents(),this.checkBreakpoint(),this.applyBackgroundColor(),this.animationEnabled&&this.animate()}applyBackgroundColor(){"transparent"!==this.config.backgroundColor&&(this.canvas.style.background=this.config.backgroundColor)}checkBreakpoint(){const t=window.innerWidth>=this.breakpoints[this.config.breakpoint];t!==this.animationEnabled&&(this.animationEnabled=t,this.animationEnabled||(this.drops=[],this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height)))}resizeCanvas(){this.canvas.width=window.innerWidth,this.canvas.height=window.innerHeight}bindEvents(){window.addEventListener("resize",()=>{this.animationPaused=!0,clearTimeout(this.resizeTimer),this.resizeTimer=setTimeout(()=>{this.resizeCanvas(),this.updateObstacles(),this.checkBreakpoint(),this.animationPaused=!1},1e3)}),this.canvas.addEventListener("click",t=>{this.animationEnabled&&this.handleClick(t)})}handleClick(t){const i=this.canvas.getBoundingClientRect(),s=t.clientX-i.left,a=t.clientY-i.top;if(!this.isPositionBlocked(s,a)){const t=this.createDrop(s,a,15,0,0,[],!1,this.config.clickDropColor);this.drops.push(t)}}isPositionBlocked(t,i){for(let s of this.obstacles)if(t>=s.x&&t<=s.x+s.width&&i>=s.y&&i<=s.y+s.height){if(!(s.radius>0))return!0;{const a=[{cx:s.x+s.radius,cy:s.y+s.radius},{cx:s.x+s.width-s.radius,cy:s.y+s.radius},{cx:s.x+s.radius,cy:s.y+s.height-s.radius},{cx:s.x+s.width-s.radius,cy:s.y+s.height-s.radius}];let e=!1;if(t<s.x+s.radius){if(i<s.y+s.radius){const o=t-a[0].cx,n=i-a[0].cy;e=o*o+n*n>s.radius*s.radius}else if(i>s.y+s.height-s.radius){const o=t-a[2].cx,n=i-a[2].cy;e=o*o+n*n>s.radius*s.radius}}else if(t>s.x+s.width-s.radius)if(i<s.y+s.radius){const o=t-a[1].cx,n=i-a[1].cy;e=o*o+n*n>s.radius*s.radius}else if(i>s.y+s.height-s.radius){const o=t-a[3].cx,n=i-a[3].cy;e=o*o+n*n>s.radius*s.radius}if(!e)return!0}}return!1}updateObstacles(){this.obstacles=[],document.querySelectorAll(".obstacle").forEach(t=>{const i=t.getBoundingClientRect(),s=window.getComputedStyle(t).borderRadius;let a=0;s&&"0px"!==s&&(a=parseFloat(s)),this.obstacles.push({x:i.left,y:i.top,width:i.width,height:i.height,radius:a,id:t.id||Math.random().toString()})})}createDrop(t=null,i=null,s=null,a=0,e=0,o=[],n=!1,h=null){const r=h||this.config.defaultDropColor;return{x:null!==t?t:Math.random()*this.canvas.width,y:null!==i?i:-20,size:null!==s?s:12+8*Math.random(),vx:a,vy:e,gravity:.15,affectedObstacles:[...o],opacity:.6+.4*Math.random(),maxSpeed:8,hasBouncedBottom:n,color:r}}getCollisionNormal(t,i,s){if(!i)return{x:0,y:-1,type:"flat"};const a=i.x+i.width,e=i.y+i.height,o=i.x+i.width/2,n=i.y+i.height/2;if(i.width===i.height&&i.radius>=i.width/2){const t=s.x-o,i=s.y-n,a=Math.sqrt(t*t+i*i);return{x:t/a,y:i/a,type:"curved"}}if(i.radius>0){const t=[{x:i.x+i.radius,y:i.y+i.radius},{x:a-i.radius,y:i.y+i.radius},{x:i.x+i.radius,y:e-i.radius},{x:a-i.radius,y:e-i.radius}];for(let a of t){const t=s.x-a.x,e=s.y-a.y,o=Math.sqrt(t*t+e*e);if(o<=i.radius+5)return{x:t/o,y:e/o,type:"curved"}}}return Math.abs(s.y-i.y)<5?{x:0,y:-1,type:"flat"}:Math.abs(s.y-e)<5?{x:0,y:1,type:"flat"}:Math.abs(s.x-i.x)<5?{x:-1,y:0,type:"flat"}:Math.abs(s.x-a)<5?{x:1,y:0,type:"flat"}:{x:0,y:-1,type:"flat"}}checkCollisionDetailed(t){if(!t.hasBouncedBottom&&t.y+t.size>=this.canvas.height)return{type:"bottom",obstacle:null,point:{x:t.x,y:this.canvas.height-t.size}};for(let i of this.obstacles){if(t.affectedObstacles.includes(i.id))continue;const s=this.getCollisionPoint(t,i);if(s)return{type:"obstacle",obstacle:i,point:s}}return null}getCollisionPoint(t,i){const s=t.x-t.size,a=t.x+t.size,e=t.y-t.size,o=t.y+t.size,n=i.x+i.width,h=i.y+i.height;if(a<i.x||s>n||o<i.y||e>h)return null;let r=t.x,c=t.y;return t.x<i.x?r=i.x:t.x>n&&(r=n),t.y<i.y?c=i.y:t.y>h&&(c=h),{x:r,y:c}}handleCollision(t,i){const s=this.getCollisionNormal(t,i.obstacle,i.point),a=t.size>this.config.minDropSize,e=4+4*Math.random(),o=[...t.affectedObstacles];i.obstacle&&o.push(i.obstacle.id);const n="bottom"===i.type,h=i.point.x,r=i.point.y;if("flat"===s.type){if(a){const i=Math.PI/4,a=.7*t.size;let c,l,d,u,y=0,x=0,p=0,b=0;if(Math.abs(s.y)>Math.abs(s.x))c=-Math.cos(i)*e,l=-Math.abs(Math.sin(i)*e),d=Math.cos(i)*e,u=-Math.abs(Math.sin(i)*e),y=.5*-t.size,p=.5*t.size,s.y,x=2*-t.size,b=2*-t.size;else{const a=Math.sign(s.x);c=a*Math.cos(i)*e,l=-Math.abs(Math.sin(i)*e),d=a*Math.cos(i)*e,u=-Math.abs(Math.sin(i)*e*.7),y=s.x*t.size*2,p=s.x*t.size*2,x=1*-t.size,b=.5*-t.size}return[this.createDrop(h+y,r+x,a,c,l,o,n,t.color),this.createDrop(h+p,r+b,a,d,u,o,n,t.color)]}{const i=Math.PI/4,a=Math.random()>.5?1:-1;let h,r;return Math.abs(s.y)>Math.abs(s.x)?(h=a*Math.cos(i)*e,r=-Math.abs(Math.sin(i)*e)):(h=Math.sign(s.x)*Math.cos(i)*e,r=-Math.abs(Math.sin(i)*e)),t.x+=s.x*(t.size+2),t.y+=s.y*(t.size+2),t.vx=h,t.vy=r,t.affectedObstacles=o,n&&(t.hasBouncedBottom=!0),null}}{const i=t.vx*s.x+t.vy*s.y,c=t.vx-2*i*s.x,l=t.vy-2*i*s.y,d=Math.abs(l),u=Math.sqrt(c*c+d*d),y=u>0?c/u:0,x=u>0?-d/u:-1;if(a){const i=.7*t.size,a=.3,c=t.size+2;return[this.createDrop(h+s.x*c,r+s.y*c,i,y*e-s.y*a*e,x*e+s.x*a*e,o,n,t.color),this.createDrop(h+s.x*c,r+s.y*c,i,y*e+s.y*a*e,x*e-s.x*a*e,o,n,t.color)]}return t.x+=s.x*(t.size+2),t.y+=s.y*(t.size+2),t.vx=y*e,t.vy=x*e,t.affectedObstacles=o,n&&(t.hasBouncedBottom=!0),null}}updateDrops(){if(!this.animationEnabled)return;const t=[];for(let i=this.drops.length-1;i>=0;i--){const s=this.drops[i];s.vy+=s.gravity,s.vy>s.maxSpeed&&(s.vy=s.maxSpeed),s.x+=s.vx,s.y+=s.vy,s.vx*=.98;const a=this.checkCollisionDetailed(s);if(a){const e=this.handleCollision(s,a);e&&(t.push(...e),this.drops.splice(i,1))}else s.y-s.size>this.canvas.height+50&&this.drops.splice(i,1)}this.drops.push(...t)}drawDrop(t){this.ctx.save(),this.ctx.globalAlpha=t.opacity,this.ctx.fillStyle=t.color.main+t.opacity+")",this.ctx.shadowColor=t.color.shadow,this.ctx.shadowBlur=.5*t.size,this.ctx.beginPath(),this.ctx.arc(t.x,t.y,t.size,0,2*Math.PI),this.ctx.fill();const i=this.ctx.createRadialGradient(t.x-.3*t.size,t.y-.3*t.size,0,t.x,t.y,t.size);i.addColorStop(0,t.color.highlight),i.addColorStop(1,t.color.main+"0)"),this.ctx.fillStyle=i,this.ctx.beginPath(),this.ctx.arc(t.x,t.y,.8*t.size,0,2*Math.PI),this.ctx.fill(),this.ctx.restore()}animate(t=0){!this.animationPaused&&this.animationEnabled&&(this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height),t-this.lastDropTime>this.config.dropInterval&&(this.drops.push(this.createDrop()),this.lastDropTime=t),this.updateDrops(),this.drops.forEach(t=>this.drawDrop(t))),requestAnimationFrame(t=>this.animate(t))}updateConfig(t){this.config={...this.config,...t},void 0!==t.backgroundColor&&this.applyBackgroundColor(),void 0!==t.breakpoint&&this.checkBreakpoint(),void 0!==t.enabled&&(this.animationEnabled=t.enabled,this.animationEnabled||(this.drops=[],this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height)))}pause(){this.animationPaused=!0}resume(){this.animationPaused=!1}clear(){this.drops=[],this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height)}destroy(){this.animationEnabled=!1,this.clear()}}